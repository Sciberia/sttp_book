## Глава 1 – Зачем тестировать программное обеспечение?  
### Мотивация  

Добро пожаловать в первую главу книги «Тестирование программного обеспечения: от теории до практики»! С помощью этой книги 
мы научим вас, как эффективно тестировать программное обеспечение, как убедиться, что оно работает, и как максимально 
автоматизировать эти этапы.

Под тестированием ПО мы подразумеваем применение различных техник для создания тест-кейсов. Например, тестов на 
основе требований, тестов на основе исходного кода, анализ граничных значений и т.д. А под автоматизацией мы понимаем выполнение 
компьютером тех задач, на решение которых человек потратил бы слишком много времени, или тех, с которыми 
компьютер справляется лучше.

В ходе обучения вы увидите, что тестирование ПО – очень творческое занятие. Но хотя творчество — и основной принцип, мы 
будем изучать методичные и строгие правила написания тест-кейсов. Кроме того, в курсе будет много практики. Мы будем 
рассматривать применение каждого приёма на нескольких практических примерах. И приготовьтесь увидеть большое количество 
кода, написанного на Java. Надеемся, вы сможете обобщить всё, что узнаете из книги, чтобы протестировать ПО, с которым 
работаете в реальной жизни.

Итак, почему мы должны заботиться о тестировании? Потому что ошибки повсюду. И вы, как и все люди, наверняка тоже 
их совершали. При этом, некоторые ошибки могли значительно повлиять на ход вашей жизни.

Поэтому, чтобы продемонстрировать, с какой легкостью возникают ошибки, давайте начнём с требования.

Предположим, у нас есть клиент. И этот человек хочет программу, которая выдавала бы числовую последовательность, а потом возвращала бы наименьшее и наибольшее значения из этой последовательности.   
Вот так выглядит простейшая программа для выполнения этой задачи. Реализуем её на Java:

    public class Num Finder {
      private int smallest = Integer.MAX_VALUE;
      private int largest = Integer.MIN_VALUE;
    
      public void find(int[] nums) {
	      for(int n : nums) {
  	      if(n < smallest) smallest = n;
  	      else if(n > largest) largest = n;
	      }
      }

      // getters for smallest and largest
    }

Идея программы заключается в следующем: мы проверяем все элементы этой последовательности и сохраняем наименьшее число в 
одной переменной, и наибольшее число – в другой. Если n меньше наименьшего числа, мы присваиваем переменной n значение этого 
числа. То же самое мы делаем с самым большим числом: если n больше самого большого числа, мы просто присваиваем n его значение.

И, как разработчики, мы часто делаем следующее: реализуем требования, а затем выполняем небольшие проверки, чтобы убедиться, 
что всё работает. Один из способов проверить – придумать метод, который немного испытает программу.

Давайте рассмотрим в качестве примера, что произойдет, если мы выполним нашу программу с какими-нибудь случайными числами в 
качестве входных данных. Допустим, 4, 25,7 и 9.

Чтобы убедиться, что программа ведёт себя правильно, давайте просто выведем на экран самое большое и самое маленькое 
значения. Вывод отладочной информации на экран — довольно распространенный метод:

    public class NumFinder Main {
    
      public static void main (String[] args) {
	    Num Finder nf = new Num Finder();
	    nf.find(new int[] {4, 25, 7, 9});
    
	    System.out.println(nf.getLargest());
	    System.out.println(nf.getSmallest());
      }
    }

На выходе получаем: 25, 4. Это значит, что наше ПО работает! И мы можем отправить его клиенту. Или?..

У нас наверняка возникнут проблемы с этим кодом. Потому что эта программа работает не во всех возможных случаях. 
В ней есть баг. (Сможете найти баг? Вернитесь к выше приведенному коду и поищите его.)

Если мы введем входные данные: 4, 3, 2 и 1; то есть введем числа в порядке уменьшения, на выходе мы получим данные: -2147483648, 1.

У нас действительно есть баг. Прежде всего давайте исправим его. Если мы вернемся к исходному коду, то увидим, 
что ошибка вызвана else if.

    public class Num Finder {
      private int smallest = Integer.MAX_VALUE;
      private int largest = Integer.MIN_VALUE;
    
      public void find(int[] nums) {
	      for(int n : nums) {
  	      if(n < smallest) smallest = n;
    
  	      // BUG was here!!
  	      if(n > largest) largest = n;
	      }
      }

      // getters for smallest and largest
    }
    
Подумайте, почему так происходит. Это else if на самом деле должно быть просто if.

Да, это примитивная ошибка. Но суть в том, что такие ошибки могут возникать и возникают постоянно. Мы, разработчики, 
обычно работаем с очень сложным программным обеспечением, и нам трудно держать всё в голове.

Вот зачем нам необходимо тестировать программное обеспечение. Потому что ошибки случаются. И они действительно могут 
оказать большое влияние на нашу жизнь.

И именно этому мы будем уделять основное внимание в данном курсе. Надеемся, что вы сможете получить из этой книги достаточно 
знаний, чтобы тщательно протестировать ваше ПО и убедиться, что ошибок, подобных этой, не возникнет.



